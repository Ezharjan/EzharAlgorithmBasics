/*
	学号:17081160 
	姓名:艾孜尔江・艾尔斯兰 
	专业:数字媒体技术 
	时间: 24/11/18 23:51
	描述:实验四的第二题 
*/
#include<iostream> 
#define Max 100//定义最大量为100  
using namespace std;

int main()//为防止调用时出现传值错误导致效率低下的问题，直接使用主函数开始写算法 
{
    int n,m;//声明整型变量点数和边数 
	int i,j,k;//s声明计数器 
	int t,a,b,c;//生命数组中的参数 
    int e[7][7],dis[7],Vmst[7]={0};//声明并初始化每个数组 
    int count=0,sum=0;//声明并初始化计数器和求和的整型变量 
    
	cout<<"请输入图的点数： "<<endl;//提示用户输入点数 
    cin>>n;//用户输入点数 
	cout<<"请输入图的边数：  "<<endl;//提示用书输入边数 
	cin>>m;//用户输入边数 

    for(i=1;i<=n;++i)//循环计数，图的初始化 
    {
        for(j=1;j<=n;++j)//第二层循环 
        {
			if(i==j) {e[i][j]=0;}//初始化数组中的值 
			else     {e[i][j]=Max;}//将数组中的值赋为最大 
		}   
	}//图的初始化成功 
	
	cout<<"请输入变得起始点以及权值,并在输入时按空格隔开，按回车换行： "<<endl;
    for(i=1;i<=m;++i)//输入图的相应值 
    {
        cin>>a>>b>>c;//用户输入起始点以及权值 
        e[a][b]=c;//将C的值赋给数组 
        e[b][a]=c;//同上 
    }
    //初始化dis数组，这里是一号顶点到各个顶点的距离，当前生成树只有一号顶点
    for(i=1;i<=n;++i){dis[i]=e[1][i];}//循环计数并将数组的值赋给路径函数 
    Vmst[1]=1;//让数组从一开始计数 
    ++count;//不断自加 
 
    while(count<n)//Prim算法实现最小生成树 
    {
        t=Max;//迭代 
        for(i=1;i<=n;++i)//循环以重复检测邻接点 
        {
            if(Vmst[i]==0&&dis[i]<t)//寻找距离当前生成树树距离最近且未连接过的节点
            {
                t=dis[i];//将邻接点的值赋给t 
                j=i;//将计数器的值赋给就j，存储到j中 
            }
        }
        Vmst[j]=true;//j加入生成树顶点集合 
        ++count; 
        sum+=dis[j];//求得的总和值等于距离数组中所存储的值 
        //扫描顶点j的所有边，再以j为中间点，更新生成树到每一个非树顶点的距离
        for(k=1;k<=n;++k)
        {
            if(Vmst[k]==false&&dis[k]>e[j][k])//若k加入生成树不成功并且距离数组的值较大 
            dis[k]=e[j][k];//将数组中的值赋给距离数组 
        }
    }
    cout<<"最短路径为： "<<sum<<endl;//呈现最短路径 
    return 0;
}
